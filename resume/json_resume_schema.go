// Code generated by schema-generate. DO NOT EDIT.

package main

import (
    "bytes"
    "fmt"
    "encoding/json"
)

// AwardsItems 
type AwardsItems struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // e.g. Time Magazine
  Awarder string `json:"awarder,omitempty"`
  Date string `json:"date,omitempty"`

  // e.g. Received for my work with Quantum Physics
  Summary string `json:"summary,omitempty"`

  // e.g. One of the 100 greatest minds of the century
  Title string `json:"title,omitempty"`
}

// Basics 
type Basics struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // e.g. thomas@gmail.com
  Email string `json:"email,omitempty"`

  // URL (as per RFC 3986) to a image in JPEG or PNG format
  Image string `json:"image,omitempty"`

  // e.g. Web Developer
  Label string `json:"label,omitempty"`
  Location *Location `json:"location,omitempty"`
  Name string `json:"name,omitempty"`

  // Phone numbers are stored as strings so use any format you like, e.g. 712-117-2923
  Phone string `json:"phone,omitempty"`

  // Specify any number of social networks that you participate in
  Profiles []*ProfilesItems `json:"profiles,omitempty"`

  // Write a short 2-3 sentence biography about yourself
  Summary string `json:"summary,omitempty"`

  // URL (as per RFC 3986) to your website, e.g. personal homepage
  Url string `json:"url,omitempty"`
}

// CertificatesItems 
type CertificatesItems struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // e.g. 1989-06-12
  Date string `json:"date,omitempty"`

  // e.g. CNCF
  Issuer string `json:"issuer,omitempty"`

  // e.g. Certified Kubernetes Administrator
  Name string `json:"name,omitempty"`

  // e.g. http://example.com
  Url string `json:"url,omitempty"`
}

// EducationItems 
type EducationItems struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // e.g. Arts
  Area string `json:"area,omitempty"`

  // List notable courses/subjects
  Courses []string `json:"courses,omitempty"`
  EndDate string `json:"endDate,omitempty"`

  // e.g. Massachusetts Institute of Technology
  Institution string `json:"institution,omitempty"`

  // grade point average, e.g. 3.67/4.0
  Score string `json:"score,omitempty"`
  StartDate string `json:"startDate,omitempty"`

  // e.g. Bachelor
  StudyType string `json:"studyType,omitempty"`

  // e.g. http://facebook.example.com
  Url string `json:"url,omitempty"`
}

// InterestsItems 
type InterestsItems struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`
  Keywords []string `json:"keywords,omitempty"`

  // e.g. Philosophy
  Name string `json:"name,omitempty"`
}

// LanguagesItems 
type LanguagesItems struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // e.g. Fluent, Beginner
  Fluency string `json:"fluency,omitempty"`

  // e.g. English, Spanish
  Language string `json:"language,omitempty"`
}

// Location 
type Location struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // To add multiple address lines, use 
  // . For example, 1234 Glücklichkeit Straße
  // Hinterhaus 5. Etage li.
  Address string `json:"address,omitempty"`
  City string `json:"city,omitempty"`

  // code as per ISO-3166-1 ALPHA-2, e.g. US, AU, IN
  CountryCode string `json:"countryCode,omitempty"`
  PostalCode string `json:"postalCode,omitempty"`

  // The general region where you live. Can be a US state, or a province, for instance.
  Region string `json:"region,omitempty"`
}

// Meta The schema version and any other tooling configuration lives here
type Meta struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // URL (as per RFC 3986) to latest version of this document
  Canonical string `json:"canonical,omitempty"`

  // Using ISO 8601 with YYYY-MM-DDThh:mm:ss
  LastModified string `json:"lastModified,omitempty"`

  // A version field which follows semver - e.g. v1.0.0
  Version string `json:"version,omitempty"`
}

// ProfilesItems 
type ProfilesItems struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // e.g. Facebook or Twitter
  Network string `json:"network,omitempty"`

  // e.g. http://twitter.example.com/neutralthoughts
  Url string `json:"url,omitempty"`

  // e.g. neutralthoughts
  Username string `json:"username,omitempty"`
}

// ProjectsItems 
type ProjectsItems struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // Short summary of project. e.g. Collated works of 2017.
  Description string `json:"description,omitempty"`
  EndDate string `json:"endDate,omitempty"`

  // Specify the relevant company/entity affiliations e.g. 'greenpeace', 'corporationXYZ'
  Entity string `json:"entity,omitempty"`

  // Specify multiple features
  Highlights []string `json:"highlights,omitempty"`

  // Specify special elements involved
  Keywords []string `json:"keywords,omitempty"`

  // e.g. The World Wide Web
  Name string `json:"name,omitempty"`

  // Specify your role on this project or in company
  Roles []string `json:"roles,omitempty"`
  StartDate string `json:"startDate,omitempty"`

  //  e.g. 'volunteering', 'presentation', 'talk', 'application', 'conference'
  Type string `json:"type,omitempty"`

  // e.g. http://www.computer.org/csdl/mags/co/1996/10/rx069-abs.html
  Url string `json:"url,omitempty"`
}

// PublicationsItems 
type PublicationsItems struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // e.g. The World Wide Web
  Name string `json:"name,omitempty"`

  // e.g. IEEE, Computer Magazine
  Publisher string `json:"publisher,omitempty"`
  ReleaseDate string `json:"releaseDate,omitempty"`

  // Short summary of publication. e.g. Discussion of the World Wide Web, HTTP, HTML.
  Summary string `json:"summary,omitempty"`

  // e.g. http://www.computer.org.example.com/csdl/mags/co/1996/10/rx069-abs.html
  Url string `json:"url,omitempty"`
}

// ReferencesItems 
type ReferencesItems struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // e.g. Timothy Cook
  Name string `json:"name,omitempty"`

  // e.g. Joe blogs was a great employee, who turned up to work at least once a week. He exceeded my expectations when it came to doing nothing.
  Reference string `json:"reference,omitempty"`
}

// ResumeSchema 
type ResumeSchema struct {

  // Specify any awards you have received throughout your professional career
  Awards []*AwardsItems `json:"awards,omitempty"`
  Basics *Basics `json:"basics,omitempty"`

  // Specify any certificates you have received throughout your professional career
  Certificates []*CertificatesItems `json:"certificates,omitempty"`
  Education []*EducationItems `json:"education,omitempty"`
  Interests []*InterestsItems `json:"interests,omitempty"`

  // List any other languages you speak
  Languages []*LanguagesItems `json:"languages,omitempty"`

  // The schema version and any other tooling configuration lives here
  Meta *Meta `json:"meta,omitempty"`

  // Specify career projects
  Projects []*ProjectsItems `json:"projects,omitempty"`

  // Specify your publications through your career
  Publications []*PublicationsItems `json:"publications,omitempty"`

  // List references you have received
  References []*ReferencesItems `json:"references,omitempty"`

  // link to the version of the schema that can validate the resume
  Schema string `json:"$schema,omitempty"`

  // List out your professional skill-set
  Skills []*SkillsItems `json:"skills,omitempty"`
  Volunteer []*VolunteerItems `json:"volunteer,omitempty"`
  Work []*WorkItems `json:"work,omitempty"`
}

// SkillsItems 
type SkillsItems struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // List some keywords pertaining to this skill
  Keywords []string `json:"keywords,omitempty"`

  // e.g. Master
  Level string `json:"level,omitempty"`

  // e.g. Web Development
  Name string `json:"name,omitempty"`
}

// VolunteerItems 
type VolunteerItems struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`
  EndDate string `json:"endDate,omitempty"`

  // Specify accomplishments and achievements
  Highlights []string `json:"highlights,omitempty"`

  // e.g. Facebook
  Organization string `json:"organization,omitempty"`

  // e.g. Software Engineer
  Position string `json:"position,omitempty"`
  StartDate string `json:"startDate,omitempty"`

  // Give an overview of your responsibilities at the company
  Summary string `json:"summary,omitempty"`

  // e.g. http://facebook.example.com
  Url string `json:"url,omitempty"`
}

// WorkItems 
type WorkItems struct {
  AdditionalProperties map[string]interface{} `json:"-,omitempty"`

  // e.g. Social Media Company
  Description string `json:"description,omitempty"`
  EndDate string `json:"endDate,omitempty"`

  // Specify multiple accomplishments
  Highlights []string `json:"highlights,omitempty"`

  // e.g. Menlo Park, CA
  Location string `json:"location,omitempty"`

  // e.g. Facebook
  Name string `json:"name,omitempty"`

  // e.g. Software Engineer
  Position string `json:"position,omitempty"`
  StartDate string `json:"startDate,omitempty"`

  // Give an overview of your responsibilities at the company
  Summary string `json:"summary,omitempty"`

  // e.g. http://facebook.example.com
  Url string `json:"url,omitempty"`
}

func (strct *AwardsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "awarder" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"awarder\": ")
	if tmp, err := json.Marshal(strct.Awarder); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "date" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"date\": ")
	if tmp, err := json.Marshal(strct.Date); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "summary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "title" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"title\": ")
	if tmp, err := json.Marshal(strct.Title); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AwardsItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "awarder":
            if err := json.Unmarshal([]byte(v), &strct.Awarder); err != nil {
                return err
             }
        case "date":
            if err := json.Unmarshal([]byte(v), &strct.Date); err != nil {
                return err
             }
        case "summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
        case "title":
            if err := json.Unmarshal([]byte(v), &strct.Title); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Basics) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "email" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"email\": ")
	if tmp, err := json.Marshal(strct.Email); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "image" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"image\": ")
	if tmp, err := json.Marshal(strct.Image); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "label" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"label\": ")
	if tmp, err := json.Marshal(strct.Label); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "location" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "phone" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"phone\": ")
	if tmp, err := json.Marshal(strct.Phone); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "profiles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"profiles\": ")
	if tmp, err := json.Marshal(strct.Profiles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "summary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Basics) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "email":
            if err := json.Unmarshal([]byte(v), &strct.Email); err != nil {
                return err
             }
        case "image":
            if err := json.Unmarshal([]byte(v), &strct.Image); err != nil {
                return err
             }
        case "label":
            if err := json.Unmarshal([]byte(v), &strct.Label); err != nil {
                return err
             }
        case "location":
            if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "phone":
            if err := json.Unmarshal([]byte(v), &strct.Phone); err != nil {
                return err
             }
        case "profiles":
            if err := json.Unmarshal([]byte(v), &strct.Profiles); err != nil {
                return err
             }
        case "summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *CertificatesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "date" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"date\": ")
	if tmp, err := json.Marshal(strct.Date); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "issuer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"issuer\": ")
	if tmp, err := json.Marshal(strct.Issuer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *CertificatesItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "date":
            if err := json.Unmarshal([]byte(v), &strct.Date); err != nil {
                return err
             }
        case "issuer":
            if err := json.Unmarshal([]byte(v), &strct.Issuer); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *EducationItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "area" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"area\": ")
	if tmp, err := json.Marshal(strct.Area); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "courses" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"courses\": ")
	if tmp, err := json.Marshal(strct.Courses); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "endDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"endDate\": ")
	if tmp, err := json.Marshal(strct.EndDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "institution" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"institution\": ")
	if tmp, err := json.Marshal(strct.Institution); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "score" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"score\": ")
	if tmp, err := json.Marshal(strct.Score); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "startDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"startDate\": ")
	if tmp, err := json.Marshal(strct.StartDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "studyType" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"studyType\": ")
	if tmp, err := json.Marshal(strct.StudyType); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EducationItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "area":
            if err := json.Unmarshal([]byte(v), &strct.Area); err != nil {
                return err
             }
        case "courses":
            if err := json.Unmarshal([]byte(v), &strct.Courses); err != nil {
                return err
             }
        case "endDate":
            if err := json.Unmarshal([]byte(v), &strct.EndDate); err != nil {
                return err
             }
        case "institution":
            if err := json.Unmarshal([]byte(v), &strct.Institution); err != nil {
                return err
             }
        case "score":
            if err := json.Unmarshal([]byte(v), &strct.Score); err != nil {
                return err
             }
        case "startDate":
            if err := json.Unmarshal([]byte(v), &strct.StartDate); err != nil {
                return err
             }
        case "studyType":
            if err := json.Unmarshal([]byte(v), &strct.StudyType); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *InterestsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "keywords" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"keywords\": ")
	if tmp, err := json.Marshal(strct.Keywords); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *InterestsItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "keywords":
            if err := json.Unmarshal([]byte(v), &strct.Keywords); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *LanguagesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "fluency" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"fluency\": ")
	if tmp, err := json.Marshal(strct.Fluency); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "language" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"language\": ")
	if tmp, err := json.Marshal(strct.Language); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LanguagesItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "fluency":
            if err := json.Unmarshal([]byte(v), &strct.Fluency); err != nil {
                return err
             }
        case "language":
            if err := json.Unmarshal([]byte(v), &strct.Language); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Location) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "address" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "city" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"city\": ")
	if tmp, err := json.Marshal(strct.City); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "countryCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"countryCode\": ")
	if tmp, err := json.Marshal(strct.CountryCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "postalCode" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"postalCode\": ")
	if tmp, err := json.Marshal(strct.PostalCode); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "region" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"region\": ")
	if tmp, err := json.Marshal(strct.Region); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Location) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "address":
            if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
                return err
             }
        case "city":
            if err := json.Unmarshal([]byte(v), &strct.City); err != nil {
                return err
             }
        case "countryCode":
            if err := json.Unmarshal([]byte(v), &strct.CountryCode); err != nil {
                return err
             }
        case "postalCode":
            if err := json.Unmarshal([]byte(v), &strct.PostalCode); err != nil {
                return err
             }
        case "region":
            if err := json.Unmarshal([]byte(v), &strct.Region); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Meta) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "canonical" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"canonical\": ")
	if tmp, err := json.Marshal(strct.Canonical); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "lastModified" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"lastModified\": ")
	if tmp, err := json.Marshal(strct.LastModified); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "version" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"version\": ")
	if tmp, err := json.Marshal(strct.Version); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Meta) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "canonical":
            if err := json.Unmarshal([]byte(v), &strct.Canonical); err != nil {
                return err
             }
        case "lastModified":
            if err := json.Unmarshal([]byte(v), &strct.LastModified); err != nil {
                return err
             }
        case "version":
            if err := json.Unmarshal([]byte(v), &strct.Version); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *ProfilesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "network" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"network\": ")
	if tmp, err := json.Marshal(strct.Network); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "username" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"username\": ")
	if tmp, err := json.Marshal(strct.Username); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProfilesItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "network":
            if err := json.Unmarshal([]byte(v), &strct.Network); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        case "username":
            if err := json.Unmarshal([]byte(v), &strct.Username); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *ProjectsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "endDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"endDate\": ")
	if tmp, err := json.Marshal(strct.EndDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "entity" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"entity\": ")
	if tmp, err := json.Marshal(strct.Entity); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "highlights" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"highlights\": ")
	if tmp, err := json.Marshal(strct.Highlights); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "keywords" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"keywords\": ")
	if tmp, err := json.Marshal(strct.Keywords); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "roles" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"roles\": ")
	if tmp, err := json.Marshal(strct.Roles); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "startDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"startDate\": ")
	if tmp, err := json.Marshal(strct.StartDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "type" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ProjectsItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "endDate":
            if err := json.Unmarshal([]byte(v), &strct.EndDate); err != nil {
                return err
             }
        case "entity":
            if err := json.Unmarshal([]byte(v), &strct.Entity); err != nil {
                return err
             }
        case "highlights":
            if err := json.Unmarshal([]byte(v), &strct.Highlights); err != nil {
                return err
             }
        case "keywords":
            if err := json.Unmarshal([]byte(v), &strct.Keywords); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "roles":
            if err := json.Unmarshal([]byte(v), &strct.Roles); err != nil {
                return err
             }
        case "startDate":
            if err := json.Unmarshal([]byte(v), &strct.StartDate); err != nil {
                return err
             }
        case "type":
            if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *PublicationsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "publisher" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"publisher\": ")
	if tmp, err := json.Marshal(strct.Publisher); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "releaseDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"releaseDate\": ")
	if tmp, err := json.Marshal(strct.ReleaseDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "summary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PublicationsItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "publisher":
            if err := json.Unmarshal([]byte(v), &strct.Publisher); err != nil {
                return err
             }
        case "releaseDate":
            if err := json.Unmarshal([]byte(v), &strct.ReleaseDate); err != nil {
                return err
             }
        case "summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *ReferencesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "reference" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"reference\": ")
	if tmp, err := json.Marshal(strct.Reference); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ReferencesItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "reference":
            if err := json.Unmarshal([]byte(v), &strct.Reference); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *ResumeSchema) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "awards" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"awards\": ")
	if tmp, err := json.Marshal(strct.Awards); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "basics" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"basics\": ")
	if tmp, err := json.Marshal(strct.Basics); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "certificates" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"certificates\": ")
	if tmp, err := json.Marshal(strct.Certificates); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "education" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"education\": ")
	if tmp, err := json.Marshal(strct.Education); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "interests" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"interests\": ")
	if tmp, err := json.Marshal(strct.Interests); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "languages" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"languages\": ")
	if tmp, err := json.Marshal(strct.Languages); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "meta" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"meta\": ")
	if tmp, err := json.Marshal(strct.Meta); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "projects" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"projects\": ")
	if tmp, err := json.Marshal(strct.Projects); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "publications" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"publications\": ")
	if tmp, err := json.Marshal(strct.Publications); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "references" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"references\": ")
	if tmp, err := json.Marshal(strct.References); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "$schema" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"$schema\": ")
	if tmp, err := json.Marshal(strct.Schema); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "skills" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"skills\": ")
	if tmp, err := json.Marshal(strct.Skills); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "volunteer" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"volunteer\": ")
	if tmp, err := json.Marshal(strct.Volunteer); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "work" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"work\": ")
	if tmp, err := json.Marshal(strct.Work); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *ResumeSchema) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "awards":
            if err := json.Unmarshal([]byte(v), &strct.Awards); err != nil {
                return err
             }
        case "basics":
            if err := json.Unmarshal([]byte(v), &strct.Basics); err != nil {
                return err
             }
        case "certificates":
            if err := json.Unmarshal([]byte(v), &strct.Certificates); err != nil {
                return err
             }
        case "education":
            if err := json.Unmarshal([]byte(v), &strct.Education); err != nil {
                return err
             }
        case "interests":
            if err := json.Unmarshal([]byte(v), &strct.Interests); err != nil {
                return err
             }
        case "languages":
            if err := json.Unmarshal([]byte(v), &strct.Languages); err != nil {
                return err
             }
        case "meta":
            if err := json.Unmarshal([]byte(v), &strct.Meta); err != nil {
                return err
             }
        case "projects":
            if err := json.Unmarshal([]byte(v), &strct.Projects); err != nil {
                return err
             }
        case "publications":
            if err := json.Unmarshal([]byte(v), &strct.Publications); err != nil {
                return err
             }
        case "references":
            if err := json.Unmarshal([]byte(v), &strct.References); err != nil {
                return err
             }
        case "$schema":
            if err := json.Unmarshal([]byte(v), &strct.Schema); err != nil {
                return err
             }
        case "skills":
            if err := json.Unmarshal([]byte(v), &strct.Skills); err != nil {
                return err
             }
        case "volunteer":
            if err := json.Unmarshal([]byte(v), &strct.Volunteer); err != nil {
                return err
             }
        case "work":
            if err := json.Unmarshal([]byte(v), &strct.Work); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *SkillsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "keywords" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"keywords\": ")
	if tmp, err := json.Marshal(strct.Keywords); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "level" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"level\": ")
	if tmp, err := json.Marshal(strct.Level); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *SkillsItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "keywords":
            if err := json.Unmarshal([]byte(v), &strct.Keywords); err != nil {
                return err
             }
        case "level":
            if err := json.Unmarshal([]byte(v), &strct.Level); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *VolunteerItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "endDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"endDate\": ")
	if tmp, err := json.Marshal(strct.EndDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "highlights" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"highlights\": ")
	if tmp, err := json.Marshal(strct.Highlights); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "organization" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"organization\": ")
	if tmp, err := json.Marshal(strct.Organization); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "position" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"position\": ")
	if tmp, err := json.Marshal(strct.Position); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "startDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"startDate\": ")
	if tmp, err := json.Marshal(strct.StartDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "summary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *VolunteerItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "endDate":
            if err := json.Unmarshal([]byte(v), &strct.EndDate); err != nil {
                return err
             }
        case "highlights":
            if err := json.Unmarshal([]byte(v), &strct.Highlights); err != nil {
                return err
             }
        case "organization":
            if err := json.Unmarshal([]byte(v), &strct.Organization); err != nil {
                return err
             }
        case "position":
            if err := json.Unmarshal([]byte(v), &strct.Position); err != nil {
                return err
             }
        case "startDate":
            if err := json.Unmarshal([]byte(v), &strct.StartDate); err != nil {
                return err
             }
        case "summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *WorkItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "description" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "endDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"endDate\": ")
	if tmp, err := json.Marshal(strct.EndDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "highlights" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"highlights\": ")
	if tmp, err := json.Marshal(strct.Highlights); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "location" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "position" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"position\": ")
	if tmp, err := json.Marshal(strct.Position); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "startDate" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"startDate\": ")
	if tmp, err := json.Marshal(strct.StartDate); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "summary" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"summary\": ")
	if tmp, err := json.Marshal(strct.Summary); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WorkItems) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "description":
            if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
                return err
             }
        case "endDate":
            if err := json.Unmarshal([]byte(v), &strct.EndDate); err != nil {
                return err
             }
        case "highlights":
            if err := json.Unmarshal([]byte(v), &strct.Highlights); err != nil {
                return err
             }
        case "location":
            if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
                return err
             }
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "position":
            if err := json.Unmarshal([]byte(v), &strct.Position); err != nil {
                return err
             }
        case "startDate":
            if err := json.Unmarshal([]byte(v), &strct.StartDate); err != nil {
                return err
             }
        case "summary":
            if err := json.Unmarshal([]byte(v), &strct.Summary); err != nil {
                return err
             }
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}
